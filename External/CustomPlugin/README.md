The original instructions for setting up a new plugin were found here:
https://forum.babylonjs.com/t/babylonnative-questions/9716/15

Create a new empty repository on GitHub called BabylonNativePluginName.
Fork and clone the Babylon Native repository.
At the root folder of your Babylon Native repository, create a new folder called Extensions, or something like that. (Note: This new folder isn’t strictly necessary as you could theoretically add your plugin directly to the existing Plugins folder; however, doing it in a separate folder will more closely emulate how the workflow might eventually go when creating a new plugin outside the Babylon Native repository, not directly inside it.)
cd into your new Extensions folder and add your new empty repo as a submodule there.
Create a new CMakeLists.txt in your extensions folder which just calls add_subdirectory(BabylonNativePluginName), similar to how this is done for the existing Plugins folder.
Add a line to the root-level CMakeLists.txt that calls add_subdirectory(Extensions), similar to how this is done for the existing Plugins folder. (Note: you probably don’t want to start with the EXCLUDE_FROM_ALL feature enabled as this will cause the Visual Studio CMake generator to ignore your new project until some end-level target actually includes it, which shouldn’t be a problem but also isn’t necessary in your case.)
Add a line to Apps/Playground/CMakeLists.txt to introduce a dependency on BabylonNativePluginName (you’ll create this CMake target inside your plugin repository), similar to how this is done for existing plugins and polyfills.
Your Babylon Native repository is now ready to consume the plugin in your BabylonNativePluginName submodule and use it in the Playground app; I recommend committing your Babylon Native changes to a branch at this point, if you haven’t already done so.
From here, you can build your plugin however you want; the only requirement is that your plugin’s root-level CMakeLists.txt expose a BabylonNativePluginName library target that will make all your plugin’s capabilities available to the Playground app. (I recommend looking at the NativeWindow plugin for a self-contained and relatively simple example of how you might structure your plugin’s repository.) Your BabylonNativePluginName submodule will function identically to an ordinary Git repository, so you can code, commit, and push from it exactly as you would with an ordinary Git project. The only addition is that, to keep the outer repository in sync, you will need to cd out into the containing repository, git add ., and commit the new state of the submodule. This doesn’t need to be done all the time; only when you feel it’s appropriate, for example when changing an exposed function or reaching a major capability milestone.
Once your plugin’s contract is defined, it is likely that you will have some sort of initialization function that needs to be called in order to expose it to the JavaScript; this can most likely be called from App.cpp, as is done for the existing plugins and polyfills 1.